#!/usr/bin/env python3.8
# @generated by pegen from KiwiParser/grammar.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser

import KiwiAST as kiwi
from itertools import chain

# Keywords and soft keywords are listed at the end of the parser definition.
class KiwiParser(Parser):

    @memoize
    def start(self) -> Optional[kiwi . Module]:
        # start: statements? $
        mark = self._mark()
        if (
            (b := self.statements(),)
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return kiwi . Module ( b )
        self._reset(mark)
        return None

    @memoize
    def statements(self) -> Optional[Any]:
        # statements: statement+
        mark = self._mark()
        if (
            (_loop1_1 := self._loop1_1())
        ):
            return _loop1_1
        self._reset(mark)
        return None

    @memoize
    def statement(self) -> Optional[Any]:
        # statement: simple_stmt (NEWLINE | ';') | compound_stmt
        mark = self._mark()
        if (
            (v := self.simple_stmt())
            and
            (_tmp_2 := self._tmp_2())
        ):
            return v
        self._reset(mark)
        if (
            (compound_stmt := self.compound_stmt())
        ):
            return compound_stmt
        self._reset(mark)
        return None

    @memoize
    def statement_newline(self) -> Optional[Any]:
        # statement_newline: simple_stmt NEWLINE
        mark = self._mark()
        if (
            (v := self.simple_stmt())
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return v
        self._reset(mark)
        return None

    @memoize
    def simple_stmt(self) -> Optional[Any]:
        # simple_stmt: assignment | return_stmt | 'pass'
        mark = self._mark()
        if (
            (assignment := self.assignment())
        ):
            return assignment
        self._reset(mark)
        if (
            (return_stmt := self.return_stmt())
        ):
            return return_stmt
        self._reset(mark)
        if (
            (literal := self.expect('pass'))
        ):
            return kiwi . Pass ( )
        self._reset(mark)
        return None

    @memoize
    def compound_stmt(self) -> Optional[Any]:
        # compound_stmt: function_def | namespace_def | if_stmt
        mark = self._mark()
        if (
            (function_def := self.function_def())
        ):
            return function_def
        self._reset(mark)
        if (
            (namespace_def := self.namespace_def())
        ):
            return namespace_def
        self._reset(mark)
        if (
            (if_stmt := self.if_stmt())
        ):
            return if_stmt
        self._reset(mark)
        return None

    @memoize
    def assignment(self) -> Optional[Any]:
        # assignment: annotations '=' ','.expression+ | ','.NAME_+ '=' ','.expression+ | ','.NAME_+ augassign ','.expression+ | annotations
        mark = self._mark()
        if (
            (a := self.annotations())
            and
            (literal := self.expect('='))
            and
            (v := self._gather_3())
        ):
            return kiwi . AnnAssignment ( * a , v )
        self._reset(mark)
        if (
            (i := self._gather_5())
            and
            (literal := self.expect('='))
            and
            (v := self._gather_7())
        ):
            return kiwi . Assignment ( i , v )
        self._reset(mark)
        if (
            (i := self._gather_9())
            and
            (o := self.augassign())
            and
            (v := self._gather_11())
        ):
            return kiwi . AugAssignment ( i , o , v )
        self._reset(mark)
        if (
            (a := self.annotations())
        ):
            return kiwi . Annotation ( * a )
        self._reset(mark)
        return None

    @memoize
    def annotations(self) -> Optional[Any]:
        # annotations: NAME_ ':' data_type | ','.NAME_+ '->' data_type
        mark = self._mark()
        if (
            (i := self.NAME_())
            and
            (literal := self.expect(':'))
            and
            (t := self.data_type())
        ):
            return [[i] , t]
        self._reset(mark)
        if (
            (i := self._gather_13())
            and
            (literal := self.expect('->'))
            and
            (t := self.data_type())
        ):
            return i , t
        self._reset(mark)
        return None

    @memoize
    def annotation(self) -> Optional[Any]:
        # annotation: NAME_ ':' data_type
        mark = self._mark()
        if (
            (i := self.NAME_())
            and
            (literal := self.expect(':'))
            and
            (t := self.data_type())
        ):
            return [i , t]
        self._reset(mark)
        return None

    @memoize
    def augassign(self) -> Optional[Any]:
        # augassign: '+=' | '-=' | '*=' | '/=' | '%='
        mark = self._mark()
        if (
            (literal := self.expect('+='))
        ):
            return '+='
        self._reset(mark)
        if (
            (literal := self.expect('-='))
        ):
            return '-='
        self._reset(mark)
        if (
            (literal := self.expect('*='))
        ):
            return '*='
        self._reset(mark)
        if (
            (literal := self.expect('/='))
        ):
            return '/='
        self._reset(mark)
        if (
            (literal := self.expect('%='))
        ):
            return '%='
        self._reset(mark)
        return None

    @memoize
    def return_stmt(self) -> Optional[Any]:
        # return_stmt: 'return' expression
        mark = self._mark()
        if (
            (literal := self.expect('return'))
            and
            (v := self.expression())
        ):
            return kiwi . Return ( v )
        self._reset(mark)
        return None

    @memoize
    def block(self) -> Optional[Any]:
        # block: NEWLINE INDENT statements DEDENT | statement_newline
        mark = self._mark()
        if (
            (_newline := self.expect('NEWLINE'))
            and
            (_indent := self.expect('INDENT'))
            and
            (v := self.statements())
            and
            (_dedent := self.expect('DEDENT'))
        ):
            return v
        self._reset(mark)
        if (
            (v := self.statement_newline())
        ):
            return [v]
        self._reset(mark)
        return None

    @memoize
    def hiding_block(self) -> Optional[Any]:
        # hiding_block: NEWLINE INDENT blocks DEDENT
        mark = self._mark()
        if (
            (_newline := self.expect('NEWLINE'))
            and
            (_indent := self.expect('INDENT'))
            and
            (v := self.blocks())
            and
            (_dedent := self.expect('DEDENT'))
        ):
            return v
        self._reset(mark)
        return None

    @memoize
    def blocks(self) -> Optional[Any]:
        # blocks: private_block public_block | public_block private_block | private_block | public_block | statements
        mark = self._mark()
        if (
            (pr := self.private_block())
            and
            (pu := self.public_block())
        ):
            return pr [0] , pu [0] , [* pr [1] , * pu [1]]
        self._reset(mark)
        if (
            (pu := self.public_block())
            and
            (pr := self.private_block())
        ):
            return pr [0] , pu [0] , [* pr [1] , * pu [1]]
        self._reset(mark)
        if (
            (pr := self.private_block())
        ):
            return pr [0] , [] , pr [1]
        self._reset(mark)
        if (
            (pu := self.public_block())
        ):
            return [] , pu [0] , pu [1]
        self._reset(mark)
        if (
            (d := self.statements())
        ):
            return [] , [] , d
        self._reset(mark)
        return None

    @memoize
    def private_block(self) -> Optional[Any]:
        # private_block: statements 'private' ':' block statements | statements 'private' ':' block | 'private' ':' block statements | 'private' ':' block
        mark = self._mark()
        if (
            (d1 := self.statements())
            and
            (literal := self.expect('private'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
            and
            (d2 := self.statements())
        ):
            return p , [* d1 , * d2]
        self._reset(mark)
        if (
            (d := self.statements())
            and
            (literal := self.expect('private'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
        ):
            return p , d
        self._reset(mark)
        if (
            (literal := self.expect('private'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
            and
            (d := self.statements())
        ):
            return p , d
        self._reset(mark)
        if (
            (literal := self.expect('private'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
        ):
            return p , []
        self._reset(mark)
        return None

    @memoize
    def public_block(self) -> Optional[Any]:
        # public_block: statements 'public' ':' block statements | statements 'public' ':' block | 'public' ':' block statements | 'public' ':' block
        mark = self._mark()
        if (
            (d1 := self.statements())
            and
            (literal := self.expect('public'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
            and
            (d2 := self.statements())
        ):
            return p , [* d1 , * d2]
        self._reset(mark)
        if (
            (d := self.statements())
            and
            (literal := self.expect('public'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
        ):
            return p , d
        self._reset(mark)
        if (
            (literal := self.expect('public'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
            and
            (d := self.statements())
        ):
            return p , d
        self._reset(mark)
        if (
            (literal := self.expect('public'))
            and
            (literal_1 := self.expect(':'))
            and
            (p := self.block())
        ):
            return p , []
        self._reset(mark)
        return None

    @memoize
    def namespace_def(self) -> Optional[Any]:
        # namespace_def: 'namespace' NAME_ ':' hiding_block
        mark = self._mark()
        if (
            (literal := self.expect('namespace'))
            and
            (i := self.NAME_())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.hiding_block())
        ):
            return kiwi . NamespaceDef ( i , * b )
        self._reset(mark)
        return None

    @memoize
    def function_def(self) -> Optional[Any]:
        # function_def: 'function' NAME_ '(' parameters ')' '->' return_param ':' block | 'function' NAME_ '(' parameters ')' ':' block
        mark = self._mark()
        if (
            (literal := self.expect('function'))
            and
            (i := self.NAME_())
            and
            (literal_1 := self.expect('('))
            and
            (p := self.parameters())
            and
            (literal_2 := self.expect(')'))
            and
            (literal_3 := self.expect('->'))
            and
            (r := self.return_param())
            and
            (literal_4 := self.expect(':'))
            and
            (b := self.block())
        ):
            return kiwi . FuncDef ( i , p [0] , p [1] , r , b )
        self._reset(mark)
        if (
            (literal := self.expect('function'))
            and
            (i := self.NAME_())
            and
            (literal_1 := self.expect('('))
            and
            (p := self.parameters())
            and
            (literal_2 := self.expect(')'))
            and
            (literal_3 := self.expect(':'))
            and
            (b := self.block())
        ):
            return kiwi . FuncDef ( i , p [0] , p [1] , None , b )
        self._reset(mark)
        return None

    @memoize
    def parameters(self) -> Optional[Any]:
        # parameters: param_no_default* param_with_default*
        # nullable=True
        mark = self._mark()
        if (
            (p := self._loop0_15(),)
            and
            (d := self._loop0_16(),)
        ):
            return [* p , * map ( lambda x : x [0] , d )] , list ( map ( lambda x : x [1] , d ) )
        self._reset(mark)
        return None

    @memoize
    def param_no_default(self) -> Optional[Any]:
        # param_no_default: annotation ',' | annotation &')' | '=' NAME_ ',' | '=' NAME_ &')'
        mark = self._mark()
        if (
            (v := self.annotation())
            and
            (literal := self.expect(','))
        ):
            return kiwi . Parameter ( v [0] , v [1] )
        self._reset(mark)
        if (
            (v := self.annotation())
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return kiwi . Parameter ( v [0] , v [1] )
        self._reset(mark)
        if (
            (literal := self.expect('='))
            and
            (i := self.NAME_())
            and
            (literal_1 := self.expect(','))
        ):
            return kiwi . RefParameter ( i )
        self._reset(mark)
        if (
            (literal := self.expect('='))
            and
            (i := self.NAME_())
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return kiwi . RefParameter ( i )
        self._reset(mark)
        return None

    @memoize
    def param_with_default(self) -> Optional[Any]:
        # param_with_default: annotation '=' expression ',' | annotation '=' expression &')' | '=' NAME_ '=' expression ',' | '=' NAME_ '=' expression &')'
        mark = self._mark()
        if (
            (a := self.annotation())
            and
            (literal := self.expect('='))
            and
            (v := self.expression())
            and
            (literal_1 := self.expect(','))
        ):
            return kiwi . Parameter ( a [0] , a [1] ) , v
        self._reset(mark)
        if (
            (a := self.annotation())
            and
            (literal := self.expect('='))
            and
            (v := self.expression())
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return kiwi . Parameter ( a [0] , a [1] ) , v
        self._reset(mark)
        if (
            (literal := self.expect('='))
            and
            (i := self.NAME_())
            and
            (literal_1 := self.expect('='))
            and
            (v := self.expression())
            and
            (literal_2 := self.expect(','))
        ):
            return kiwi . RefParameter ( i ) , v
        self._reset(mark)
        if (
            (literal := self.expect('='))
            and
            (i := self.NAME_())
            and
            (literal_1 := self.expect('='))
            and
            (v := self.expression())
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return kiwi . RefParameter ( i ) , v
        self._reset(mark)
        return None

    @memoize
    def return_param(self) -> Optional[Any]:
        # return_param: data_type | '=' NAME_
        mark = self._mark()
        if (
            (data_type := self.data_type())
        ):
            return data_type
        self._reset(mark)
        if (
            (literal := self.expect('='))
            and
            (i := self.NAME_())
        ):
            return kiwi . RefParameter ( i )
        self._reset(mark)
        return None

    @memoize
    def if_stmt(self) -> Optional[Any]:
        # if_stmt: 'if' expression ':' block 'else' if_stmt | 'if' expression ':' block 'else' ':' block | 'if' expression ':' block
        mark = self._mark()
        if (
            (literal := self.expect('if'))
            and
            (c := self.expression())
            and
            (literal_1 := self.expect(':'))
            and
            (t := self.block())
            and
            (literal_2 := self.expect('else'))
            and
            (e := self.if_stmt())
        ):
            return kiwi . IfElse ( c , t , e )
        self._reset(mark)
        if (
            (literal := self.expect('if'))
            and
            (c := self.expression())
            and
            (literal_1 := self.expect(':'))
            and
            (t := self.block())
            and
            (literal_2 := self.expect('else'))
            and
            (literal_3 := self.expect(':'))
            and
            (e := self.block())
        ):
            return kiwi . IfElse ( c , t , e )
        self._reset(mark)
        if (
            (literal := self.expect('if'))
            and
            (c := self.expression())
            and
            (literal_1 := self.expect(':'))
            and
            (t := self.block())
        ):
            return kiwi . IfElse ( c , t , [] )
        self._reset(mark)
        return None

    @memoize
    def expression(self) -> Optional[Any]:
        # expression: inversion '?' inversion ':' inversion | inversion
        mark = self._mark()
        if (
            (c := self.inversion())
            and
            (literal := self.expect('?'))
            and
            (t := self.inversion())
            and
            (literal_1 := self.expect(':'))
            and
            (e := self.inversion())
        ):
            return kiwi . IfExpression ( c , t , e )
        self._reset(mark)
        if (
            (v := self.inversion())
        ):
            return kiwi . Expression ( v )
        self._reset(mark)
        return None

    @memoize
    def inversion(self) -> Optional[Any]:
        # inversion: '!' inversion | comparison
        mark = self._mark()
        if (
            (literal := self.expect('!'))
            and
            (x := self.inversion())
        ):
            return kiwi . UnaryOp ( x , '!' )
        self._reset(mark)
        if (
            (comparison := self.comparison())
        ):
            return comparison
        self._reset(mark)
        return None

    @memoize
    def comparison(self) -> Optional[Any]:
        # comparison: sum compare_op_sum_pair+ | sum
        mark = self._mark()
        if (
            (f := self.sum())
            and
            (v := self._loop1_17())
        ):
            return kiwi . Compare ( [f , * list ( map ( lambda x : x [1] , v ) )] , list ( map ( lambda x : x [0] , v ) ) )
        self._reset(mark)
        if (
            (sum := self.sum())
        ):
            return sum
        self._reset(mark)
        return None

    @memoize
    def compare_op_sum_pair(self) -> Optional[Any]:
        # compare_op_sum_pair: eq_sum | noteq_sum | lte_sum | lt_sum | gte_sum | gt_sum
        mark = self._mark()
        if (
            (eq_sum := self.eq_sum())
        ):
            return eq_sum
        self._reset(mark)
        if (
            (noteq_sum := self.noteq_sum())
        ):
            return noteq_sum
        self._reset(mark)
        if (
            (lte_sum := self.lte_sum())
        ):
            return lte_sum
        self._reset(mark)
        if (
            (lt_sum := self.lt_sum())
        ):
            return lt_sum
        self._reset(mark)
        if (
            (gte_sum := self.gte_sum())
        ):
            return gte_sum
        self._reset(mark)
        if (
            (gt_sum := self.gt_sum())
        ):
            return gt_sum
        self._reset(mark)
        return None

    @memoize
    def eq_sum(self) -> Optional[Any]:
        # eq_sum: '==' sum
        mark = self._mark()
        if (
            (literal := self.expect('=='))
            and
            (sum := self.sum())
        ):
            return [literal, sum]
        self._reset(mark)
        return None

    @memoize
    def noteq_sum(self) -> Optional[Any]:
        # noteq_sum: '!=' sum
        mark = self._mark()
        if (
            (literal := self.expect('!='))
            and
            (sum := self.sum())
        ):
            return [literal, sum]
        self._reset(mark)
        return None

    @memoize
    def lte_sum(self) -> Optional[Any]:
        # lte_sum: '<=' sum
        mark = self._mark()
        if (
            (literal := self.expect('<='))
            and
            (sum := self.sum())
        ):
            return [literal, sum]
        self._reset(mark)
        return None

    @memoize
    def lt_sum(self) -> Optional[Any]:
        # lt_sum: '<' sum
        mark = self._mark()
        if (
            (literal := self.expect('<'))
            and
            (sum := self.sum())
        ):
            return [literal, sum]
        self._reset(mark)
        return None

    @memoize
    def gte_sum(self) -> Optional[Any]:
        # gte_sum: '>=' sum
        mark = self._mark()
        if (
            (literal := self.expect('>='))
            and
            (sum := self.sum())
        ):
            return [literal, sum]
        self._reset(mark)
        return None

    @memoize
    def gt_sum(self) -> Optional[Any]:
        # gt_sum: '>' sum
        mark = self._mark()
        if (
            (literal := self.expect('>'))
            and
            (sum := self.sum())
        ):
            return [literal, sum]
        self._reset(mark)
        return None

    @memoize_left_rec
    def sum(self) -> Optional[Any]:
        # sum: sum '+' term | sum '-' term | term
        mark = self._mark()
        if (
            (x := self.sum())
            and
            (literal := self.expect('+'))
            and
            (y := self.term())
        ):
            return kiwi . BinaryOp ( x , y , '+' )
        self._reset(mark)
        if (
            (x := self.sum())
            and
            (literal := self.expect('-'))
            and
            (y := self.term())
        ):
            return kiwi . BinaryOp ( x , y , '-' )
        self._reset(mark)
        if (
            (term := self.term())
        ):
            return term
        self._reset(mark)
        return None

    @memoize_left_rec
    def term(self) -> Optional[Any]:
        # term: term '*' factor | term '/' factor | term '%' factor | factor
        mark = self._mark()
        if (
            (x := self.term())
            and
            (literal := self.expect('*'))
            and
            (y := self.factor())
        ):
            return kiwi . BinaryOp ( x , y , '*' )
        self._reset(mark)
        if (
            (x := self.term())
            and
            (literal := self.expect('/'))
            and
            (y := self.factor())
        ):
            return kiwi . BinaryOp ( x , y , '/' )
        self._reset(mark)
        if (
            (x := self.term())
            and
            (literal := self.expect('%'))
            and
            (y := self.factor())
        ):
            return kiwi . BinaryOp ( x , y , '%' )
        self._reset(mark)
        if (
            (factor := self.factor())
        ):
            return factor
        self._reset(mark)
        return None

    @memoize
    def factor(self) -> Optional[Any]:
        # factor: '+' factor | '-' factor | power
        mark = self._mark()
        if (
            (literal := self.expect('+'))
            and
            (x := self.factor())
        ):
            return kiwi . UnaryOp ( x , '+' )
        self._reset(mark)
        if (
            (literal := self.expect('-'))
            and
            (x := self.factor())
        ):
            return kiwi . UnaryOp ( x , '-' )
        self._reset(mark)
        if (
            (power := self.power())
        ):
            return power
        self._reset(mark)
        return None

    @memoize
    def power(self) -> Optional[Any]:
        # power: atom '**' factor | atom
        mark = self._mark()
        if (
            (x := self.atom())
            and
            (literal := self.expect('**'))
            and
            (y := self.factor())
        ):
            return kiwi . BinaryOp ( x , y , '**' )
        self._reset(mark)
        if (
            (atom := self.atom())
        ):
            return atom
        self._reset(mark)
        return None

    @memoize
    def atom(self) -> Optional[Any]:
        # atom: NAME_ | 'true' | 'false' | 'none' | STRING_ | NUMBER_ | group
        mark = self._mark()
        if (
            (NAME_ := self.NAME_())
        ):
            return NAME_
        self._reset(mark)
        if (
            (literal := self.expect('true'))
        ):
            return 'true'
        self._reset(mark)
        if (
            (literal := self.expect('false'))
        ):
            return 'false'
        self._reset(mark)
        if (
            (literal := self.expect('none'))
        ):
            return 'none'
        self._reset(mark)
        if (
            (STRING_ := self.STRING_())
        ):
            return STRING_
        self._reset(mark)
        if (
            (NUMBER_ := self.NUMBER_())
        ):
            return NUMBER_
        self._reset(mark)
        if (
            (group := self.group())
        ):
            return group
        self._reset(mark)
        return None

    @memoize
    def group(self) -> Optional[Any]:
        # group: '(' expression ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (expression := self.expression())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, expression, literal_1]
        self._reset(mark)
        return None

    @memoize
    def data_type(self) -> Optional[Any]:
        # data_type: 'score' | 'scoreboard' | 'auto'
        mark = self._mark()
        if (
            (literal := self.expect('score'))
        ):
            return 'score'
        self._reset(mark)
        if (
            (literal := self.expect('scoreboard'))
        ):
            return 'scoreboard'
        self._reset(mark)
        if (
            (literal := self.expect('auto'))
        ):
            return 'auto'
        self._reset(mark)
        return None

    @memoize
    def NUMBER_(self) -> Optional[Any]:
        # NUMBER_: NUMBER
        mark = self._mark()
        if (
            (v := self.number())
        ):
            return int ( v . string )
        self._reset(mark)
        return None

    @memoize
    def NAME_(self) -> Optional[Any]:
        # NAME_: NAME
        mark = self._mark()
        if (
            (v := self.name())
        ):
            return v . string
        self._reset(mark)
        return None

    @memoize
    def STRING_(self) -> Optional[Any]:
        # STRING_: STRING+
        mark = self._mark()
        if (
            (v := self._loop1_18())
        ):
            return kiwi . String ( '' . join ( map ( lambda x : x . string [1 : - 1] , v ) ) )
        self._reset(mark)
        return None

    @memoize
    def _loop1_1(self) -> Optional[Any]:
        # _loop1_1: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: NEWLINE | ';'
        mark = self._mark()
        if (
            (_newline := self.expect('NEWLINE'))
        ):
            return _newline
        self._reset(mark)
        if (
            (literal := self.expect(';'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: ',' expression
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_3(self) -> Optional[Any]:
        # _gather_3: expression _loop0_4
        mark = self._mark()
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_4())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_6(self) -> Optional[Any]:
        # _loop0_6: ',' NAME_
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.NAME_())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_5(self) -> Optional[Any]:
        # _gather_5: NAME_ _loop0_6
        mark = self._mark()
        if (
            (elem := self.NAME_())
            is not None
            and
            (seq := self._loop0_6())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_8(self) -> Optional[Any]:
        # _loop0_8: ',' expression
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_7(self) -> Optional[Any]:
        # _gather_7: expression _loop0_8
        mark = self._mark()
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_8())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: ',' NAME_
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.NAME_())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_9(self) -> Optional[Any]:
        # _gather_9: NAME_ _loop0_10
        mark = self._mark()
        if (
            (elem := self.NAME_())
            is not None
            and
            (seq := self._loop0_10())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_12(self) -> Optional[Any]:
        # _loop0_12: ',' expression
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_11(self) -> Optional[Any]:
        # _gather_11: expression _loop0_12
        mark = self._mark()
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_12())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_14(self) -> Optional[Any]:
        # _loop0_14: ',' NAME_
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.NAME_())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_13(self) -> Optional[Any]:
        # _gather_13: NAME_ _loop0_14
        mark = self._mark()
        if (
            (elem := self.NAME_())
            is not None
            and
            (seq := self._loop0_14())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_15(self) -> Optional[Any]:
        # _loop0_15: param_no_default
        mark = self._mark()
        children = []
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_16(self) -> Optional[Any]:
        # _loop0_16: param_with_default
        mark = self._mark()
        children = []
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_17(self) -> Optional[Any]:
        # _loop1_17: compare_op_sum_pair
        mark = self._mark()
        children = []
        while (
            (compare_op_sum_pair := self.compare_op_sum_pair())
        ):
            children.append(compare_op_sum_pair)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_18(self) -> Optional[Any]:
        # _loop1_18: STRING
        mark = self._mark()
        children = []
        while (
            (string := self.string())
        ):
            children.append(string)
            mark = self._mark()
        self._reset(mark)
        return children

    KEYWORDS = ('public', 'auto', 'if', 'function', 'pass', 'private', 'namespace', 'scoreboard', 'else', 'score', 'true', 'none', 'false', 'return')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(KiwiParser)
