# STARTING RULES
# ==============

@class KiwiParser
@subheader '''
import frontend.KiwiAST as kiwi
from itertools import chain
'''

start[kiwi.Module]:
    | i=import_stmts v=statements ENDMARKER {kiwi.Module(i, v)}
    | i=import_stmts ENDMARKER {kiwi.Module(i, [])}
    | v=statements ENDMARKER {kiwi.Module([], v)}
    | ENDMARKER {kiwi.Module([], [])}

# IMPORT STATEMENTS
# =================

import_stmts:
    | import_stmt+

import_stmt:
    | "import" v=dotted_as_names (NEWLINE | ';')+ {v}

dotted_as_names:
    | ','.dotted_as_name+

dotted_as_name:
    | v=dotted_name "as" a=NAME_ {kiwi.Alias(v, a)}
    | v=dotted_name {kiwi.Alias(v, None)}

dotted_name:
    | v=dotted_name '.' a=NAME_ {[*v, a]}
    | v=NAME_ {[v]}

# GENERAL STATEMENTS
# ==================

statements:
    | statement+

statement:
    | v=simple_stmt (NEWLINE | ';')+ {v}
    | compound_stmt

statement_newline:
    | v=simple_stmt (NEWLINE)+ {v}

simple_stmt:
    | assignment
    | expression
    | return_stmt
    | 'pass' {kiwi.Pass()}
    | 'break' {kiwi.Break()}
    | 'continue' {kiwi.Continue()}

compound_stmt:
    | function_def
    | namespace_def
    | if_stmt

# SIMPLE STATEMENTS
# =================

assignment:
    | a=annotations '=' v=','.expression+ {kiwi.AnnAssignment(*a, v)}
    | i=','.NAME_+ '=' v=','.expression+ {kiwi.Assignment(i, v)}
    | i=','.NAME_+ o=augassign v=','.expression+ {kiwi.AugAssignment(i, o, v)}
    | a=annotations {kiwi.Annotation(*a)}

annotations:
    | i=NAME_ ':' t=data_type {[[i], t]}
    | i=','.NAME_+ '->' t=data_type {i, t}

annotation:
    | i=NAME_ ':' t=data_type {[i, t]}

augassign:
    | '+=' {kiwi.Token('+=')}
    | '-=' {kiwi.Token('-=')}
    | '*=' {kiwi.Token('*=')}
    | '/=' {kiwi.Token('/=')}
    | '%=' {kiwi.Token('%=')}

return_stmt:
    | 'return' v=expression {kiwi.Return(v)}

# COMPOUND STATEMENTS
# ===================

# Common elements
# ---------------

block:
    | NEWLINE INDENT v=statements DEDENT {v}
    | v=statement_newline {[v]}

hiding_block:
    | NEWLINE INDENT v=blocks DEDENT {v}

blocks:
    | pr=private_block pu=public_block {pr[0], pu[0], [*pr[1], *pu[1]]}
    | pu=public_block pr=private_block {pr[0], pu[0], [*pr[1], *pu[1]]}
    | pr=private_block {pr[0], [], pr[1]}
    | pu=public_block {[], pu[0], pu[1]}
    | d=statements {[], [], d}

private_block:
    | d1=statements 'private' ':' p=block d2=statements {p, [*d1, *d2]}
    | d=statements 'private' ':' p=block {p, d}
    | 'private' ':' p=block d=statements {p, d}
    | 'private' ':' p=block {p, []}

public_block:
    | d1=statements 'public' ':' p=block d2=statements {p, [*d1, *d2]}
    | d=statements 'public' ':' p=block {p, d}
    | 'public' ':' p=block d=statements {p, d}
    | 'public' ':' p=block {p, []}

# Namespace definitions
# ---------------------

namespace_def:
    | 'namespace' i=NAME_ ':' b=hiding_block {kiwi.NamespaceDef(i, *b)}

# Function definitions
# --------------------

function_def:
    | 'function' i=NAME_ '(' p=parameters ')' '->' r=return_param ':' b=block {kiwi.FuncDef(i, p[0], p[1], r, b)}
    | 'function' i=NAME_ '(' p=parameters ')' ':' b=block {kiwi.FuncDef(i, p[0], p[1], None, b)}

parameters:
    | p=param_no_default* d=param_with_default* {[*p, *map(lambda x: x[0], d)], list(map(lambda x: x[1], d))}

param_no_default:
    | v=annotation ',' {kiwi.Parameter(v[0], v[1])}
    | v=annotation &')'{kiwi.Parameter(v[0], v[1])}
    | '=' i=NAME_ ',' {kiwi.RefParameter(i)}
    | '=' i=NAME_ &')' {kiwi.RefParameter(i)}

param_with_default:
    | a=annotation '=' v=expression ',' {kiwi.Parameter(a[0], a[1]), v}
    | a=annotation '=' v=expression &')' {kiwi.Parameter(a[0], a[1]), v}
    | '=' i=NAME_ '=' v=expression ',' {kiwi.RefParameter(i), v}
    | '=' i=NAME_ '=' v=expression &')' {kiwi.RefParameter(i), v}

return_param:
    | data_type
    | '=' i=NAME_ {kiwi.RefParameter(i)}

if_stmt:
    | 'if' c=expression ':' t=block 'else' e=if_stmt {kiwi.IfElse(c, t, e)}
    | 'if' c=expression ':' t=block 'else' ':' e=block {kiwi.IfElse(c, t, e)}
    | 'if' c=expression ':' t=block {kiwi.IfElse(c, t, [])}

# EXPRESSIONS
# -----------

expression:
    | lambda_def
    | c=inversion '?' t=inversion ':' e=inversion {kiwi.IfExpression(c, t, e)}
    | v=inversion {kiwi.Expression(v)}

lambda_def:
    | "lambda" p=lambda_parameters ':' r=expression {kiwi.LambdaDef(p, r)}

lambda_parameters:
    | v=','.lambda_param+ {v}
    | [lambda_param] {[]}

lambda_param:
    | v=NAME_ {kiwi.LambdaParameter(v)}

inversion:
    | '!' x=inversion {kiwi.UnaryOp(x, '!')}
    | comparison

# Comparison operators
# --------------------

comparison:
    | f=sum v=compare_op_sum_pair+ {kiwi.Compare([f, *list(map(lambda x: x[1], v))], list(map(lambda x: x[0], v)))}
    | sum

compare_op_sum_pair:
    | eq_sum
    | noteq_sum
    | lte_sum
    | lt_sum 
    | gte_sum
    | gt_sum

eq_sum:
    | o='==' v=sum {kiwi.Token(o), v}

noteq_sum:
    | o='!=' v=sum {kiwi.Token(o), v}

lte_sum:
    | o='<=' v=sum {kiwi.Token(o), v}

lt_sum:
    | o='<' v=sum {kiwi.Token(o), v}

gte_sum:
    | o='>=' v=sum {kiwi.Token(o), v}

gt_sum:
    | o='>' v=sum {kiwi.Token(o), v}

# Arithmetic operators
# --------------------

sum:
    | x=sum '+' y=term {kiwi.BinaryOp(x, y, kiwi.Token('+'))}
    | x=sum '-' y=term {kiwi.BinaryOp(x, y, kiwi.Token('-'))}
    | term

term:
    | x=term '*' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('*'))}
    | x=term '/' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('/'))}
    | x=term '%' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('%'))}
    | factor

factor:
    | '+' x=factor {kiwi.UnaryOp(x, kiwi.Token('+'))}
    | '-' x=factor {kiwi.UnaryOp(x, kiwi.Token('-'))}
    | power

power:
    | x=primary '**' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('**'))}
    | primary

primary:
    | v=primary '.' a=NAME_ {kiwi.Attribute(v, a)}
    | i=primary '(' v=arguments ')' {kiwi.Call(i, v)}
    | "match" k=expression ':' c=key_block {kiwi.MatchExpr(k, c)}
    | atom

atom:
    | NAME_
    | constant
    | group

constant:
    | 'true' {kiwi.Token('true')}
    | 'false' {kiwi.Token('false')}
    | 'none' {kiwi.Token('none')}
    | SELECTOR_
    | STRING_
    | NUMBER_

group:
    | '(' expression ')'

# FUNCTION CALL ARGUMENTS
# =======================

arguments:
    | v=args ','? &')' {v}

args:
    | v=','.expression+ {v}
    | expression? {[]}

# MATCH KEYS
# ==========

key_block:
    | NEWLINE INDENT v=NEWLINE.match_key+ NEWLINE {v} # AAAH!! I HATE PEGEN, I SPENT ABOUT 1 HOUR TO UNDERSTAND THAT PEGEN CAN BE SOME STUPID WITH DEDENT

match_key:
    | f=constant "to" t=constant '->' v=expression {kiwi.MatchKey(f, t, v)}
    | f=constant '->' v=expression {kiwi.MatchKey(f, f, v)}

# DATA TYPES
# ----------

data_type:
    | 'score' {kiwi.Token('score')}
    | 'scoreboard' {kiwi.Token('scoreboard')}
    | 'selector' {kiwi.Token('selector')}
    | 'auto' {kiwi.Token('auto')}

NUMBER_:
    | v=NUMBER {kiwi.Number(v.string)}

NAME_:
    | v=NAME {kiwi.Name(v.string)}

STRING_:
    | v=STRING+ {kiwi.String(''.join(map(lambda x: x.string[1:-1], v)))}

SELECTOR_:
    | '@' v=NAME {kiwi.Selector(v.string)}
