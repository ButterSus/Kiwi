# """
# This code is unlicensed
# By ButterSus
# 
# Previous stage:
#     Tokenizer
# 
# About current stage:
#     This stage is used to generate Abstract Syntax Tree
#     AST -> SAO
# 
# Next stage:
#     SAO
# """


# STARTING RULES
# ==============

@class KiwiParser

@header '''"""
This code is unlicensed
By ButterSus

Previous stage:
    Tokenizer

About current stage:
    This stage is used to generate Abstract Syntax Tree
    AST -> SAO

Next stage:
    SAO

Generated using pegen:
    https://we-like-parsers.github.io/pegen/index.html
    (THANK YOU SO MUCH FOR THIS BEAUTIFUL INSTRUMENT!)
"""


from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
'''

@subheader '''
import frontend.KiwiAST as kiwi
from itertools import chain

'''

start[kiwi.Module]:
    | i=import_stmts v=statements ENDMARKER {kiwi.Module(i, v)}
    | i=import_stmts ENDMARKER {kiwi.Module(i, [])}
    | v=statements ENDMARKER {kiwi.Module([], v)}
    | ENDMARKER {kiwi.Module([], [])}

# IMPORT STATEMENTS
# =================

import_stmts:
    | v=(import_stmt | from_import_stmt)+ {list(chain.from_iterable(v))}

import_stmt:
    | "import" v=dotted_as_names (NEWLINE | ';')+ {v}

from_import_stmt:
    | "from" v=dotted_name a=import_stmt {[kiwi.Alias(''.join(v), a)]}
    

dotted_as_names:
    | ','.dotted_as_name+

dotted_as_name:
    | v=dotted_name "as" a=NAME_ {kiwi.Alias(''.join(v), a)}
    | v=dotted_name {kiwi.Alias(''.join(v), v[-1])}

dotted_name:
    | v=dotted_name '.' a=NAME_ {[*v, a]}
    | v=NAME_ {[v]}

# GENERAL STATEMENTS
# ==================

statements:
    | statement+

statement:
    | v=simple_stmt (NEWLINE | ';')+ {v}
    | v=compound_stmt {v}

statement_newline:
    | v=simple_stmt (NEWLINE)+ {v}

simple_stmt:
    | assignment
    | expression
    | return_stmt
    | 'pass' {kiwi.Pass()}
    | 'break' {kiwi.Break()}
    | 'continue' {kiwi.Continue()}

compound_stmt:
    | function_def
    | namespace_def
    | if_stmt
    | while_stmt
    | match_stmt

# SIMPLE STATEMENTS
# =================

assignment:
    | a=annotations '=' v=','.expression+ {kiwi.AnnAssignment(*a, v)}
    | i=','.expression+ '=' v=','.expression+ {kiwi.Assignment(i, v)}
    | i=','.expression+ o=augassign v=','.expression+ {kiwi.AugAssignment(i, o, v)}
    | a=annotations {kiwi.Annotation(*a)}

annotations:
    | i=expression ':' t=expression {[[i], t]}
    | i=','.expression+ '->' t=expression {i, t}

augassign:
    | '+=' {kiwi.Token('+=')}
    | '-=' {kiwi.Token('-=')}
    | '*=' {kiwi.Token('*=')}
    | '/=' {kiwi.Token('/=')}
    | '%=' {kiwi.Token('%=')}

return_stmt:
    | 'return' v=expression {kiwi.Return(v)}

# COMPOUND STATEMENTS
# ===================

# Common elements
# ---------------

block:
    | NEWLINE INDENT v=statements DEDENT NEWLINE {v}
    | v=statement_newline {[v]}

hiding_block:
    | NEWLINE INDENT v=blocks DEDENT NEWLINE {v}

blocks:
    | pr=private_block pu=public_block {pr[0], pu[0], [*pr[1], *pu[1]]}
    | pu=public_block pr=private_block {pr[0], pu[0], [*pr[1], *pu[1]]}
    | pr=private_block {pr[0], [], pr[1]}
    | pu=public_block {[], pu[0], pu[1]}
    | d=statements {[], [], d}

private_block:
    | d1=statements 'private' ':' p=block d2=statements {p, [*d1, *d2]}
    | d=statements 'private' ':' p=block {p, d}
    | 'private' ':' p=block d=statements {p, d}
    | 'private' ':' p=block {p, []}

public_block:
    | d1=statements 'public' ':' p=block d2=statements {p, [*d1, *d2]}
    | d=statements 'public' ':' p=block {p, d}
    | 'public' ':' p=block d=statements {p, d}
    | 'public' ':' p=block {p, []}

# Namespace definitions
# ---------------------

namespace_def:
    | 'namespace' i=NAME_ ':' b=hiding_block {kiwi.NamespaceDef(i, *b)}

# Function definitions
# --------------------

function_def:
    | 'function' i=NAME_ '(' p=parameters ')' '->' r=return_param '<' '-' pr=expression ':' b=block {kiwi.FuncDef(i, p[0], p[1], r, pr, b)}
    | 'function' i=NAME_ '(' p=parameters ')' '<' '-' pr=expression ':' b=block {kiwi.FuncDef(i, p[0], p[1], None, pr, b)}
    | 'function' i=NAME_ '(' p=parameters ')' '->' r=return_param ':' b=block {kiwi.FuncDef(i, p[0], p[1], r, None, b)}
    | 'function' i=NAME_ '(' p=parameters ')' ':' b=block {kiwi.FuncDef(i, p[0], p[1], None, None, b)}

parameters:
    | p=param_no_default* d=param_with_default* {[*p, *map(lambda x: x[0], d)], list(map(lambda x: x[1], d))}

param_no_default:
    | v=annotations ',' {kiwi.Parameter(v[0], v[1])}
    | v=annotations &')'{kiwi.Parameter(v[0], v[1])}
    | '=' i=NAME_ ',' {kiwi.RefParameter(i)}
    | '=' i=NAME_ &')' {kiwi.RefParameter(i)}

param_with_default:
    | a=annotations '=' v=expression ',' {kiwi.Parameter(a[0], a[1]), v}
    | a=annotations '=' v=expression &')' {kiwi.Parameter(a[0], a[1]), v}
    | '=' i=NAME_ '=' v=expression ',' {kiwi.RefParameter(i), v}
    | '=' i=NAME_ '=' v=expression &')' {kiwi.RefParameter(i), v}

return_param:
    | expression
    | '=' i=NAME_ {kiwi.RefParameter(i)}

if_stmt:
    | 'if' c=expression ':' t=block 'else' e=if_stmt {kiwi.IfElse(c, t, e)}
    | 'if' c=expression ':' t=block 'else' ':' e=block {kiwi.IfElse(c, t, e)}
    | 'if' c=expression ':' t=block {kiwi.IfElse(c, t, [])}

while_stmt:
    | 'while' c=expression ':' b=block {kiwi.While(c, b)}

match_stmt:
    | "match" v=expression ':' c=case_block {kiwi.MatchCase(v, c)}

case_block:
    | NEWLINE INDENT v=cases DEDENT NEWLINE {v}

cases:
    | (',' NEWLINE*).case+

case:
    | "case" k=expression ':' b=block {kiwi.Case(k, b)}

# EXPRESSIONS
# -----------

expression:
    | lambda_def
    | c=inversion '?' t=inversion ':' e=inversion {kiwi.IfExpression(c, t, e)}
    | v=inversion {kiwi.Expression(v)}

lambda_def:
    | "lambda" p=lambda_parameters ':' r=expression {kiwi.LambdaDef(p, r)}

lambda_parameters:
    | v=','.lambda_param+ {v}
    | [lambda_param] {[]}

lambda_param:
    | v=NAME_ {kiwi.LambdaParameter(v)}

inversion:
    | '!' x=inversion {kiwi.UnaryOp(x, '!')}
    | comparison

# Comparison operators
# --------------------

comparison:
    | f=sum v=compare_op_sum_pair+ {kiwi.Compare([f, *list(map(lambda x: x[1], v))], list(map(lambda x: x[0], v)))}
    | sum

compare_op_sum_pair:
    | eq_sum
    | noteq_sum
    | lte_sum
    | lt_sum 
    | gte_sum
    | gt_sum

eq_sum:
    | '==' v=sum {kiwi.Token('=='), v}

noteq_sum:
    | '!=' v=sum {kiwi.Token('!='), v}

lte_sum:
    | '<=' v=sum {kiwi.Token('<='), v}

lt_sum:
    | '<' v=sum {kiwi.Token('<'), v}

gte_sum:
    | '>=' v=sum {kiwi.Token('>='), v}

gt_sum:
    | '>' v=sum {kiwi.Token('>'), v}

# Arithmetic operators
# --------------------

sum:
    | x=sum '+' y=term {kiwi.BinaryOp(x, y, kiwi.Token('+'))}
    | x=sum '-' y=term {kiwi.BinaryOp(x, y, kiwi.Token('-'))}
    | term

term:
    | x=term '*' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('*'))}
    | x=term '/' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('/'))}
    | x=term '%' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('%'))}
    | factor

factor:
    | '+' x=factor {kiwi.UnaryOp(x, kiwi.Token('+'))}
    | '-' x=factor {kiwi.UnaryOp(x, kiwi.Token('-'))}
    | power

power:
    | x=primary '**' y=factor {kiwi.BinaryOp(x, y, kiwi.Token('**'))}
    | primary

primary:
    | "match" k=expression ':' c=key_block {kiwi.MatchExpr(k, c)}
    | v=primary '.' a=NAME_ {kiwi.Attribute(v, a)}
    | i=primary '(' v=arguments ')' {kiwi.Call(i, v)}
    | i=primary '(' ')' {kiwi.Call(i, [])}
    | atom

atom:
    | NAME_
    | 'true' {kiwi.Token('true')}
    | 'false' {kiwi.Token('false')}
    | 'none' {kiwi.Token('none')}
    | 'promise' {kiwi.Token('promise')}
    | SELECTOR_
    | STRING_
    | NUMBER_
    | group

group:
    | '(' v=expression ')' {v}

# FUNCTION CALL ARGUMENTS
# =======================

arguments:
    | v=args ','? &')' {v}

args:
    | v=','.expression+ {v}

# MATCH KEYS
# ==========

key_block:
    | NEWLINE INDENT v=match_keys NEWLINE DEDENT {v}

match_keys:
    | (',' NEWLINE*).match_key+

match_key:
    | "default" '->' v=expression {kiwi.MatchKey(None, None, v)}
    | f=expression "to" t=expression '->' v=expression {kiwi.MatchKey(f, t, v)}
    | f=expression '->' v=expression {kiwi.MatchKey(f, f, v)}

# TOKES
# -----

NUMBER_:
    | v=NUMBER {kiwi.Number(v.string)}

NAME_:
    | v=NAME {kiwi.Name(v.string)}

WORD_:
    | v=(NUMBER | NAME)+ {kiwi.Word(''.join(list(map(str, v))))}

STRING_:
    | v=STRING+ {kiwi.String(''.join(map(lambda x: x.string, v)))}

SELECTOR_:
    | '@' v=NAME {kiwi.Selector(v.string)}
